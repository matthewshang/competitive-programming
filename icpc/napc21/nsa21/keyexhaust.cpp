#include <bits/stdc++.h>
using namespace std;

uint8_t base16_to_base10(char d) {
    if ('0' <= d && d <= '9') {
        return d - '0';
    } else {
        return 10 + (d - 'a');
    }
}

char base10_to_base16(uint8_t v) {
    if (0 <= v && v <= 9) {
        return '0' + v;
    } else {
        return 'a' + (v - 10);
    }
}

vector<uint8_t> xor_key(const vector<uint8_t>& k, const uint8_t x) {
    auto res = k;
    for (uint8_t& e : res) {
        e ^= x;
    }
    return res;
}

struct RC4 {
    constexpr static int Size = 256;

    array<uint8_t, Size> S;
    int var;
    int i, j;

    RC4() = default;

    RC4(const vector<uint8_t>& K, const int offset, const int var_) {
        var = var_;
        iota(S.begin(), S.end(), 0);
        j = 0;
        for (i = 0; i < Size; i++) {
            if (var == 2) {
                j = (j + S[i] + K[j % K.size()]) % Size;
            } else if (var == 3) {
                j = (j + S[j] + K[i % K.size()]) % Size;
            } else {
                j = (j + S[i] + K[i % K.size()]) % Size;
            }
            swap(S[i], S[j]);
        }
        i = j = 0;

        for (int k = 0; k < offset; k++) {
            gen();
        }
    }

    uint8_t gen() {
        i = (i + 1) % Size;
        j = (j + S[i]) % Size;
        swap(S[i], S[j]);
        if (var == 1) {
            return S[S[(S[i] + S[j]) % Size]];
        } else {
            return S[(S[i] + S[j]) % Size];
        }
    }
};

struct Stream {
    RC4 R1, R2, R3, R4;
    Stream(const vector<uint8_t>& k, const int v1, const int v2, const int v3, const int v4) {
        R1 = RC4(k, 256, v1);
        R2 = RC4(xor_key(k, 0x55), 1437, v2);
        R3 = RC4(xor_key(k, 0xaa), 512, v3);
        R4 = RC4(xor_key(k, 0x01), 1352, v4);
    }

    uint8_t gen() {
        return R1.gen() ^ R2.gen() ^ R3.gen() ^ R4.gen();
    }
};

// Generated by hex_to_bin
const string Gen = "38 5 1 2 5 10 5 2 2 5 10 5 3 2 6 9 5 5 2 5 10 5 6 2 5 10 5 7 2 6 9 5 9 2 5 10 5 10 2 5 10 6 0 2 5 10 6 1 2 5 10 6 2 2 5 10 6 3 1 6 6 4 2 5 10 6 5 2 5 10 6 6 1 5 6 7 2 6 9 6 8 2 5 10 6 9 2 5 10 6 10 2 5 10 9 0 2 6 9 9 1 2 6 9 9 2 2 6 9 9 3 2 6 9 9 4 2 6 9 9 5 2 6 9 9 6 2 6 9 9 7 1 9 9 8 2 6 9 9 9 2 6 9 9 10 1 9 10 1 2 5 10 10 2 2 5 10 10 3 2 6 9 10 5 2 5 10 10 6 2 5 10 10 7 2 6 9 10 9 2 5 10 10 10 2 5 10";
const string Same = "0 1 2 3 4 5 6 7 12 13 14 15 20 21 22 23 28 29 30 31 32 33 34 35 36 37 38 39 44 45 46 47 52 53 54 55 60 61 62 63 64 65 66 67 68 69 70 71 76 77 78 79 84 85 86 87 92 93 94 95 96 97 98 99 100 101 102 103 108 109 110 111 116 117 118 119 124 125 126 127";
const string Val = "00000000000000000000111100000000000000001000000000000000000001110000000000000000";

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    map<pair<int, int>, vector<int>> g;
    vector<int> same;
    {
        stringstream ss(Gen);
        int n;
        ss >> n;
        while (n--) {
            int a, b;
            ss >> a >> b;
            int s;
            ss >> s;
            while (s--) {
                int x;
                ss >> x;
                g[{a, b}].push_back(x);
            }
        }
        g[{6, 3}].push_back(9);
        g[{6, 6}].push_back(10);
        g[{9, 7}].push_back(6);
        g[{9, 10}].push_back(6);
    }
    {
        stringstream ss(Same);
        for (int i = 0; i < 80; i++) {
            int x;
            ss >> x;
            same.push_back(x);
        }
    }

    auto interleave = [&](const vector<uint8_t>& v) -> bitset<48> {
        assert(v.size() == 12);
        bitset<48> b;
        for (int i = 0; i < 12; i++) {
            bitset<8> x(v[i]);
            b[i] = x[0];
            b[12 + i] = x[1];
            b[24 + i] = x[2];
            b[36 + i] = x[3];
        }
        return b;
    };

    vector<bitset<48>> generated;
    vector<uint8_t> cur; 
    function<void(int, int)> visit = [&](int i, int l) {
        cur.push_back(i);
        if (l == 11) {
            generated.push_back(interleave(cur));
        }
        for (int to : g[{i, l}]) {
            visit(to, l + 1);
        }
        cur.pop_back();
    };
    visit(6, 0);
    visit(9, 0);
    cout << generated.size() << endl;

    vector<vector<uint8_t>> keys;
    for (const bitset<48>& bs : generated) {
        bitset<128> K1;
        int pos = 0;
        int pos2 = 0;
        for (int i = 0; i < 128; i++) {
            if (pos < 80 && same[pos] == i) {
                K1[i] = Val[pos] - '0';
                pos++;
            } else {
                K1[i] = bs[pos2];
                pos2++;
            }
        }

        vector<uint8_t> K(16);
        for (int i = 0; i < 16; i++) {
            for (int j = 0; j < 8; j++) {
                K[i] = (K[i] << 1) | K1[i * 8 + j];
            }
        }
        keys.push_back(K);
    }

    const string answer = "tlv_format_6";
    int t;
    cin >> t;
    while (t--) {
        string data_str;
        cin >> data_str;
        vector<uint8_t> data(data_str.size() / 2);
        for (int i = 0; i < int(data.size()); i++) {
            uint8_t hi = base16_to_base10(data_str[i * 2]);
            uint8_t lo = base16_to_base10(data_str[i * 2 + 1]);
            data[i] = (hi << 4) | lo;
        }
        assert(data.size() == 12);

        for (const auto& K : keys) {
            Stream stream(K, 2, 3, 0, 1);
            vector<uint8_t> cipher;
            for (int i = 0; i < 12; i++) {
                cipher.push_back(stream.gen());
            }
            vector<uint8_t> decrypted;
            for (int i = 0; i < 12; i++) {
                decrypted.push_back(data[i] ^ cipher[i]);
            }

            string res;
            for (int i = 0; i < 12; i++) {
                res += static_cast<char>(decrypted[i]);
            }

            if (answer == res) {
                for (uint8_t byte : cipher) {
                    cout << base10_to_base16(byte >> 4);
                    cout << base10_to_base16(byte & 0xF);
                }
                cout << endl;
            }
        }
    }

    return 0;
}